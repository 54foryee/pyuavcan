Full-featured UAVCAN stack in Python
====================================

[![Travis CI](https://travis-ci.org/UAVCAN/pyuavcan.svg?branch=uavcan-v1.0)](https://travis-ci.org/UAVCAN/pyuavcan)
[![Coverage Status](https://coveralls.io/repos/github/UAVCAN/pyuavcan/badge.svg?branch=uavcan-v1.0)](https://coveralls.io/github/UAVCAN/pyuavcan)
[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=UAVCAN_pyuavcan&metric=alert_status)](https://sonarcloud.io/dashboard?id=UAVCAN_pyuavcan)
[![Reliability Rating](https://sonarcloud.io/api/project_badges/measure?project=UAVCAN_pyuavcan&metric=reliability_rating)](https://sonarcloud.io/dashboard?id=UAVCAN_pyuavcan)
[![Lines of Code](https://sonarcloud.io/api/project_badges/measure?project=UAVCAN_pyuavcan&metric=ncloc)](https://sonarcloud.io/dashboard?id=UAVCAN_pyuavcan)
[![PyPI - Python Version](https://img.shields.io/pypi/pyversions/pyuavcan.svg)](https://pypi.org/project/pyuavcan/)
[![Forum](https://img.shields.io/discourse/https/forum.uavcan.org/users.svg)](https://forum.uavcan.org)

PyUAVCAN is a full-featured implementation of the [UAVCAN protocol stack](https://uavcan.org) in Python.
PyUAVCAN aims to support all features and transport layers of UAVCAN,
be portable across all major platforms supporting Python, and
be extensible to permit low-effort experimentation and testing of new protocol capabilities.

UAVCAN is an open lightweight data bus standard designed for reliable intravehicular communication
in aerospace and robotic applications via CAN bus, Ethernet, and other robust transports.

If you have questions, please bring them to the [UAVCAN support forum](https://forum.uavcan.org/).

## Installation

Install from PIP: `pip install pyuavcan`.

Note that a similar library titled `uavcan` is also available from PIP,
which implements an early experimental version of the protocol known as UAVCAN v0
that is no longer recommended for new designs.
It should not be confused with this library (titled `pyuavcan`) which implements the
long-term stable version of the protocol known as UAVCAN v1.0.

## Usage

The library is currently under active development, and as such, the usage documentation is not yet available.
Please come back later.
If you are willing to help, please join the
[UAVCAN Development & Maintenance forum](https://forum.uavcan.org/c/dev) for coordination.

## FAQ

**Q:** PyUAVCAN seems complex. Does that mean that UAVCAN is a complex protocol?
**A:** UAVCAN is a very simple protocol. This particular implementation may appear convoluted because it is very
generic and provides a very high-level API. For comparison, there is a full-featured UAVCAN-over-CAN
implementation in C99 only ~1k LoC large.

## Development

### Semantic naming conventions

API functions and methods that contain the following parameters should adhere to the semantic naming conventions:

 Type                                   | Name                  | Purpose
----------------------------------------|-----------------------|----------------------------------------------------------
`pydsdl.*Type`                          | `model`               | PyDSDL type model (descriptor).
`pyuavcan.dsdl.*Object`                 | `obj`                 | Instance of a generated class implementing a DSDL type.
`typing.Type[pyuavcan.dsdl.*Object]`    | `dtype`               | Generated class implementing a DSDL type.
`float`                                 | `monotonic_deadline`  | Abort operation if not completed by this time.
`int`                                   | `node_id`             | A node identifier.

### Writing tests

Aim to cover 100% of the code in the branch coverage mode, excepting the DSDL generated packages.

Write unit tests as functions without arguments prefixed with `_unittest_`;
optionally, for slow test functions use the prefix `_unittest_slow_` (more on this below).
Generally, simple test functions should be located as close as possible to the tested code,
preferably at the end of the same Python module; exception applies to the sub-package `pyuavcan.application`,
which is unconditionally excluded from unit test discovery because it relies on DSDL autogenerated code,
meaning that if you write your unit test function in there it will never be invoked.
Complex functions that require sophisticated setup and teardown process or that can't be located near the
tested code for other reasons shall be moved into the separate test package (aptly named `tests`).
Test functions that are located inside the library are shipped together with the library,
which makes having complex testing logic inside the main codebase undesirable.

Tests that are implemented inside the main codebase shall not use any external dependencies that are not
listed among the runtime library dependencies; for example, the library `pytest` cannot be imported
because it will break the library outside of test-enabled environments.
You can do that only in the separate test package since it's never shipped and hence does not need to work
outside of test-enabled environments.

By default, all test functions will be executed during a testing session.
Since some of them may take a considerable time to run,
the developer may want to temporarily disable slow tests by setting the environment variable
`PYUAVCAN_TEST_SKIP_SLOW=1`.
This will trigger the test executor to skip test functions whose names match the pattern `_unittest_slow_*`.

For more information refer to the PyTest documentation.

### Running tests and static analysis

The script `test.sh` can be used to run the unit tests and static code analysis tools locally.
The coverage statistics will be collected and stored in the project root directory.

After the tests are executed, it is possible to run the [SonarQube](https://sonarqube.org) scanner as follows:
`sonar-scanner -Dsonar.login=<project-key>`.
The scanner should not be run before the general test suite since it relies on its coverage data.

## License

The library is available under the terms of the MIT License.
