#!/usr/bin/env python3

import sys
import time
import pathlib
import logging
import argparse


logging.basicConfig(stream=sys.stderr,
                    level=logging.WARNING,
                    format='%(asctime)s %(process)5d %(levelname)-8s %(name)s: %(message)s')

_logger = logging.getLogger(__name__.replace('__', ''))

try:
    import pyuavcan
except ImportError:
    _logger.warning('Running from sources')
    sys.path.append(str(pathlib.Path(__file__).absolute().parent.parent))
    import pyuavcan

# noinspection PyCompatibility
import commands

sys.path.insert(0, str(commands.DEFAULT_DSDL_GENERATED_PACKAGES_DIR))


def _main() -> int:
    root_parser = argparse.ArgumentParser(
        description='''
A command line tool for diagnostics and management of UAVCAN networks.
This tool is built on top of PyUAVCAN -- a full-featured Python implementation
of the UAVCAN stack for high-level operating systems.
Find documentation and support at https://uavcan.org.
'''.strip(),
        formatter_class=argparse.RawTextHelpFormatter,
    )

    # Register common arguments
    root_parser.add_argument(
        '--version', '-V',
        action='version',
        version='%(prog)s ' + '.'.join(map(str, pyuavcan.__version__)),
        help='''
Print the PyUAVCAN version string and exit.
This application is versioned synchronously with the library.
'''.strip(),
    )
    root_parser.add_argument(
        '--verbose', '-v',
        action='count',
        help='''
Increase the verbosity of the output. Specify twice for extra verbosity.
'''.strip(),
    )

    # Register commands
    subparsers = root_parser.add_subparsers()
    for cmd in commands.COMMANDS:
        if cmd.info.examples:
            epilog = 'Examples:\n' + cmd.info.examples
        else:
            epilog = ''

        parser = subparsers.add_parser(
            cmd.name,
            help=cmd.info.help,
            epilog=epilog,
            aliases=cmd.info.aliases,
            formatter_class=argparse.RawTextHelpFormatter,
        )

        cmd.register_arguments(parser)
        parser.set_defaults(func=cmd.execute)

    # Parse args and run the command
    args = root_parser.parse_args()

    logging.root.setLevel({
        0: logging.WARNING,
        1: logging.INFO,
        2: logging.DEBUG,
    }.get(args.verbose or 0, logging.DEBUG))

    _logger.debug('Available command modules: %s', commands.COMMANDS)
    _logger.debug('Parsed args: %s', args)

    if hasattr(args, 'func'):
        started_at = time.monotonic()
        result = args.func(args)
        _logger.debug('Command executed in %.1f seconds', time.monotonic() - started_at)
        assert isinstance(result, int)
        return result
    else:
        print('No command specified, nothing to do. Run with --help for usage help. '
              'Online support: https://forum.uavcan.org.', file=sys.stderr)
        print('Available commands:', file=sys.stderr)
        for cmd in commands.COMMANDS:
            text = f'\t{cmd.name}'
            if cmd.info.aliases:
                text += f' (aliases: {", ".join(cmd.info.aliases)})'
            print(text, file=sys.stderr)
        return 1


if __name__ == '__main__':
    try:
        exit(_main())
    except KeyboardInterrupt:
        _logger.info('Interrupted')
        _logger.debug('Stack trace where the program has been interrupted', exc_info=True)
        exit(1)
    except Exception as ex:
        print('Error (run with -v for more info): %s:' % type(ex).__name__, ex, file=sys.stderr)
        _logger.info('Unhandled exception: %s', ex, exc_info=True)
        exit(1)
