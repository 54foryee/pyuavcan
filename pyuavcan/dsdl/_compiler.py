#
# Copyright (c) 2019 UAVCAN Development Team
# This software is distributed under the terms of the MIT License.
# Author: Pavel Kirienko <pavel.kirienko@zubax.com>
#

import gzip
import typing
import pickle
import base64
import keyword
import pathlib
import builtins
import itertools
import dataclasses

import pydsdl
import nunavut
import nunavut.jinja
import nunavut.postprocessors

#: Set of identifier names that are automatically stropped by the DSDL compiler.
#: The stropping is necessary because these identifiers cannot be safely overridden in a Python program.
#: Stropping is implemented by the addition of one underscore at the end of a disallowed identifier;
#: e.g., ``if`` transforms into ``if_``. This applies to all entities, including module names.
#: This is not to be confused with identifiers reserved by the DSDL language itself -- those are managed entirely
#: by the DSDL front-end, this library is not concerned with that at all.
ILLEGAL_IDENTIFIERS: typing.Set[str] = set(map(str, list(keyword.kwlist) + dir(builtins)))

_AnyPath = typing.Union[str, pathlib.Path]

_TEMPLATE_DIRECTORY: pathlib.Path = pathlib.Path(__file__).absolute().parent / pathlib.Path('_templates')

#: Read-only for all because the files are autogenerated and should not be edited manually.
_OUTPUT_FILE_PERMISSIONS = 0o444


@dataclasses.dataclass(frozen=True)
class GeneratedPackageInfo:
    #: Path to the directory that contains the top-level ``__init__.py``.
    path: pathlib.Path

    #: List of PyDSDL objects describing the source DSDL definitions.
    #: This can be used for arbitrarily complex introspection and reflection.
    models: typing.List[pydsdl.CompositeType]

    #: The name of the generated package, which is the same as the name of the DSDL root namespace unless
    #: the name had to be stropped. See :data:`ILLEGAL_IDENTIFIERS`.
    name: str


def generate_package(package_parent_directory:        _AnyPath,
                     root_namespace_directory:        _AnyPath,
                     lookup_directories:              typing.Iterable[_AnyPath] = (),
                     allow_unregulated_fixed_port_id: bool = False) -> GeneratedPackageInfo:
    """
    This function runs the DSDL compiler, converting a specified DSDL root namespace into a Python package.
    In the generated package, nested DSDL namespaces are represented as Python subpackages,
    DSDL types as Python classes, type version numbers as class name suffixes separated via underscores
    (like ``Type_1_0``), constants as class attributes, fields as properties.
    For a more detailed information on how to use generated types, just generate them and read the resulting
    code -- it is made to be human-readable and contains docstrings.

    Generated packages do not automatically import their nested subpackages. For example, if the application
    needs to use ``uavcan.node.Heartbeat.1.0``, it has to ``import uavcan.node`` explicitly; doing just
    ``import uavcan`` is not sufficient.

    If the source definition contains identifiers, type names, namespace components, or other entities whose
    names are listed in :data:`ILLEGAL_IDENTIFIERS`, the compiler applies stropping by suffixing such entities
    with an underscore ``_``.

    A small subset of applications may require access to a generated entity without knowing in advance whether
    its name is a reserved identifier or not (i.e., whether it's stropped or not). To simplify usage,
    this submodule provides helper functions
    :func:`pyuavcan.dsdl.get_attribute` and :func:`pyuavcan.dsdl.set_attribute` that provide access to generated
    class/object attributes using their original names before stropping.
    Likewise, the function :func:`pyuavcan.dsdl.get_model` can find a generated type even if any of its name
    components are stropped; e.g., a DSDL type ``str.Type.1.0`` would be imported as ``str_.Type_1_0``.

    The above, however, is irrelevant for an application that does not require genericity (vast majority of
    applications don't), so a much easier approach in that case is just to look at the generated code and see
    if there are any stropped identifiers in it, and then just use appropriate names statically.

    The recommended usage pattern for this function is lazy generation.
    First, add the ``package_parent_directory`` to :data:`sys.path` to make its contents importable.
    Then try importing the target DSDL-generated package. If the attempt is successful, our job here is done.
    Otherwise, the package(s) need(s) to be generated by invoking this function,
    and then another import attempt will have to be made.
    Beware that before retrying the import it's necessary to invoke :func:`importlib.invalidate_caches`.

    A package generated for a particular version of PyUAVCAN may be incompatible with any other version of the
    library. If your application relies on lazy generation, consider including the library version string
    :data:`pyuavcan.__version__` in ``package_parent_directory``, so that the generated package cache is
    invalidated automatically when a different version of the library is used.

    Having generated a package, consider updating the include path set of your Python IDE to take advantage
    of code completion and static type checking.

    :param package_parent_directory: The generated Python package directory will be placed into this directory.
        For example, if this argument equals ``foo/bar``, and the DSDL root namespace name is ``uavcan``,
        the top-level ``__init__.py`` of the generated package will end up in ``foo/bar/uavcan/__init__.py``.
        The directory tree will be created automatically if it does not exist (like ``mkdir -p``).
        If the destination exists, it will be silently written over.

    :param root_namespace_directory: The source DSDL root namespace directory path. The last component of the path
        is the name of the root namespace. For example, to generate package for the root namespace ``uavcan``,
        the path would be like ``foo/bar/uavcan``.

    :param lookup_directories: An iterable of DSDL root namespace directory paths where to search for referred DSDL
        definitions. The format of each path is the same as for the previous parameter; i.e., the last component
        of each path is a DSDL root namespace name. If you are generating code for a vendor-specific DSDL root
        namespace, make sure to provide at least the path to the standard ``uavcan`` namespace directory here.

    :param allow_unregulated_fixed_port_id: If True, the DSDL processing front-end will not reject unregulated
        data types with fixed port-ID. If you are not sure what it means, do not use it, and read the UAVCAN
        specification first. The default is False.

    :return: An instance of :class:`GeneratedPackageInfo` describing the generated package.

    :raises: :class:`OSError` if required operations on the file system could not be performed;
        ``pydsdl.InvalidDefinitionError`` if the source DSDL definitions are invalid;
        ``pydsdl.InternalError`` if there is a bug in the DSDL processing front-end;
        :class:`ValueError` if any of the arguments are otherwise invalid.

    The following table is an excerpt from the UAVCAN specification. Observe that *unregulated fixed port identifiers*
    are prohibited by default, but it can be overridden.

    +-------+---------------------------------------------------+----------------------------------------------+
    |Scope  | Regulated                                         | Unregulated                                  |
    +=======+===================================================+==============================================+
    |Public |Standard and contributed (e.g., vendor-specific)   |Definitions distributed separately from the   |
    |       |definitions. Fixed port identifiers are allowed;   |UAVCAN specification. Fixed port identifiers  |
    |       |they are called *"regulated port-IDs"*.            |are *not allowed*.                            |
    +-------+---------------------------------------------------+----------------------------------------------+
    |Private|Nonexistent category.                              |Definitions that are not available to anyone  |
    |       |                                                   |except their authors. Fixed port identifiers  |
    |       |                                                   |are permitted (although not recommended); they|
    |       |                                                   |are called *"unregulated fixed port-IDs"*.    |
    +-------+---------------------------------------------------+----------------------------------------------+

    Here is a brief usage example:

    >>> import sys
    >>> import pathlib
    >>> import tempfile
    >>> import importlib
    >>> import pyuavcan
    >>> dsdl_generated_dir = pathlib.Path(tempfile.gettempdir(), 'dsdl-for-my-program', pyuavcan.__version__)
    >>> dsdl_generated_dir.mkdir(parents=True, exist_ok=True)
    >>> sys.path.insert(0, str(dsdl_generated_dir))
    >>> try:
    ...     import sirius_cyber_corp
    ...     import uavcan.si.sample.volumetric_flow_rate
    ... except (ImportError, AttributeError):
    ...     _ = pyuavcan.dsdl.generate_package(package_parent_directory=dsdl_generated_dir,
    ...                                        root_namespace_directory='tests/dsdl/namespaces/sirius_cyber_corp',
    ...                                        lookup_directories=['tests/public_regulated_data_types/uavcan'])
    ...     _ = pyuavcan.dsdl.generate_package(package_parent_directory=dsdl_generated_dir,
    ...                                        root_namespace_directory='tests/public_regulated_data_types/uavcan')
    ...     importlib.invalidate_caches()
    ...     import sirius_cyber_corp
    ...     import uavcan.si.sample.volumetric_flow_rate
    """
    # Read the DSDL definitions
    composite_types = pydsdl.read_namespace(root_namespace_directory=str(root_namespace_directory),
                                            lookup_directories=list(map(str, lookup_directories)),
                                            allow_unregulated_fixed_port_id=allow_unregulated_fixed_port_id)
    root_namespace_name, = set(map(lambda x: x.root_namespace, composite_types))  # type: str,
    # TODO: the root namespace name may have to be stropped. For example, if it's named "if", it'd break.

    # Template primitives
    filters = {
        'id':                _make_identifier,
        'alignment_prefix':  _make_serialization_alignment_prefix,
        'pickle':            _pickle_object,
        'numpy_scalar_type': _numpy_scalar_type,
        'longest_id_length': lambda c: max(map(len, map(_make_identifier, c))),
        'imports':           _list_imports,
        'bit_length_set':    pydsdl.BitLengthSet,
        'full_reference':    (lambda t: f'{t.full_name}_{t.version.major}_{t.version.minor}'),
        'short_reference':   (lambda t: f'{t.short_name}_{t.version.major}_{t.version.minor}'),
    }

    tests = _construct_instance_tests_from_root(pydsdl.SerializableType)
    tests['PaddingField'] = lambda x: isinstance(x, pydsdl.PaddingField)
    tests['saturated'] = _test_if_saturated

    # Generate code
    # TODO: add support for stropping; see https://github.com/UAVCAN/nunavut/issues/23.
    root_ns = nunavut.build_namespace_tree(types=composite_types,
                                           root_namespace_dir=root_namespace_directory,
                                           output_dir=str(package_parent_directory),
                                           extension='.py',
                                           namespace_output_stem='__init__')
    generator = nunavut.jinja.Generator(namespace=root_ns,
                                        generate_namespace_types=True,
                                        templates_dir=_TEMPLATE_DIRECTORY,
                                        followlinks=True,
                                        additional_filters=filters,
                                        additional_tests=tests)
    generator.generate_all(
        post_processors=[
            nunavut.postprocessors.SetFileMode(_OUTPUT_FILE_PERMISSIONS),
            nunavut.postprocessors.LimitEmptyLines(2),
            nunavut.postprocessors.TrimTrailingWhitespace(),
        ],
    )

    return GeneratedPackageInfo(path=pathlib.Path(package_parent_directory) / pathlib.Path(root_namespace_name),
                                models=composite_types,
                                name=root_namespace_name)


def _make_identifier(a: pydsdl.Attribute) -> str:
    out = (a.name + '_') if a.name in ILLEGAL_IDENTIFIERS else a.name
    assert isinstance(out, str)
    return out


def _make_serialization_alignment_prefix(offset: pydsdl.BitLengthSet) -> str:
    if isinstance(offset, pydsdl.BitLengthSet):
        return 'aligned' if offset.is_aligned_at_byte() else 'unaligned'
    else:  # pragma: no cover
        raise TypeError(f'Expected BitLengthSet, got {type(offset).__name__}')


def _pickle_object(x: typing.Any) -> str:
    pck: str = base64.b85encode(gzip.compress(pickle.dumps(x, protocol=4))).decode().strip()
    segment_gen = map(''.join, itertools.zip_longest(*([iter(pck)] * 100), fillvalue=''))
    return '\n'.join(repr(x) for x in segment_gen)


def _numpy_scalar_type(t: pydsdl.Any) -> str:
    def pick_width(w: int) -> int:
        for o in [8, 16, 32, 64]:
            if w <= o:
                return o
        raise ValueError(f'Invalid bit width: {w}')  # pragma: no cover

    if isinstance(t, pydsdl.BooleanType):
        return f'_np_.bool'
    elif isinstance(t, pydsdl.SignedIntegerType):
        return f'_np_.int{pick_width(t.bit_length)}'
    elif isinstance(t, pydsdl.UnsignedIntegerType):
        return f'_np_.uint{pick_width(t.bit_length)}'
    elif isinstance(t, pydsdl.FloatType):
        return f'_np_.float{pick_width(t.bit_length)}'
    else:
        assert not isinstance(t, pydsdl.PrimitiveType), 'Forgot to handle some primitive types'
        return f'_np_.object_'


def _list_imports(t: pydsdl.CompositeType) -> typing.List[str]:
    # Make a list of all attributes defined by this type
    if isinstance(t, pydsdl.ServiceType):
        atr = t.request_type.attributes + t.response_type.attributes
    else:
        atr = t.attributes

    # Extract data types of said attributes; for type constructors such as arrays extract the element type
    dep_types = list(map(lambda x: x.data_type, atr))  # type: ignore
    for t in dep_types[:]:
        if isinstance(t, pydsdl.ArrayType):
            dep_types.append(t.element_type)

    # Make a list of unique full namespaces of referenced composites
    return list(sorted(set(x.full_namespace for x in dep_types if isinstance(x, pydsdl.CompositeType))))


def _test_if_saturated(t: pydsdl.PrimitiveType) -> bool:
    if isinstance(t, pydsdl.PrimitiveType):
        return {
            pydsdl.PrimitiveType.CastMode.SATURATED: True,
            pydsdl.PrimitiveType.CastMode.TRUNCATED: False,
        }[t.cast_mode]
    else:  # pragma: no cover
        raise TypeError(f'Cast mode is not defined for {type(t).__name__}')


def _construct_instance_tests_from_root(root: typing.Type[object]) \
        -> typing.Dict[str, typing.Callable[[typing.Any], bool]]:
    out = {
        root.__name__: lambda x: isinstance(x, root)
    }
    # noinspection PyArgumentList
    for derived in root.__subclasses__():
        out.update(_construct_instance_tests_from_root(derived))
    return out


# noinspection PyUnusedLocal
def _unittest_instance_tests_from_root() -> None:
    class Aa:
        pass

    class Bb(Aa):
        pass

    class Cc(Bb):
        pass

    class Dd(Aa):
        pass

    assert set(_construct_instance_tests_from_root(Aa).keys()) == {'Aa', 'Bb', 'Cc', 'Dd'}
