#
# AUTOGENERATED, DO NOT EDIT.
#
# Source file:
# {{ T.source_file_path }}
#
# Generated at:  {{ now_utc }} UTC
# Is deprecated: {{ T.deprecated and 'yes' or 'no' }}
# Fixed port ID: {{ T.fixed_port_id }}
# Full name:     {{ T.full_name }}
# Version:       {{ T.version.major }}.{{ T.version.minor }}
#

{% if T.deprecated -%}
from warnings import warn as _warn_
{%- endif %}
import numpy as _np_
from typing import Optional as _Optional_, List as _List_, Union as _Union_
from pyuavcan.dsdl import CompositeObject as _CompositeObject_
from pydsdl import StructureType as _StructureType_, UnionType as _UnionType_
{% block imports %}{% endblock %}


{# #}
{%- macro composite_ref(t) -%}
    {{ t.full_name }}_{{ t.version.major }}_{{ t.version.minor }}
{%- endmacro -%}

{%- macro strict_type_annotation(t) -%}
    {%-   if t is boolean   -%} bool
    {%- elif t is integer   -%} int
    {%- elif t is float     -%} float
    {%- elif t is array     -%} _np_.ndarray
    {%- elif t is composite -%} {{ composite_ref(t) }}
    {%- else -%}{% assert False %}
    {%- endif -%}
{%- endmacro -%}

{%- macro relaxed_type_annotation(t) -%}
    {%-   if t is boolean   -%} bool
    {%- elif t is integer   -%} _Union_[int, {{ t|numpy_scalar_type }}]
    {%- elif t is float     -%} _Union_[int, float, {{ t|numpy_scalar_type }}]
    {%- elif t is composite -%} {{ composite_ref(t) }}
    {%- elif t is array -%}
        {%- if t.element_type is uint8 -%}  _Union_[_np_.ndarray, _List_[int], bytes, bytearray]
        {%- else -%}                        _Union_[_np_.ndarray, _List_[{{ strict_type_annotation(t.element_type) }}]]
        {%- endif -%}
    {%- else -%}{% assert False %}
    {%- endif -%}
{%- endmacro -%}

{%- macro new_field(f) -%}
    self._{{ f|id }}: {{ strict_type_annotation(f.data_type) }}
{%- endmacro -%}

{%- macro new_const(c, siblings) -%}
    {{ c|id }}: {{ ''.ljust(siblings|longest_name_length - c|id|length) }}{{ strict_type_annotation(c.data_type) }}
{%- endmacro -%}

{%- macro assign_array(t, dst, src) -%}
    {%- if t is fixed_array -%}         {%- set cmp = '!=' -%}
    {%- elif t is variable_array -%}    {%- set cmp = '>' -%}
    {%- else -%}                        {%- assert False -%}
    {%- endif -%}
    if len({{ src }}) {{ cmp }} {{ t.capacity }}:
        raise ValueError(f'{{ src }}: invalid array length: {len({{ src }})} {{ cmp }} {{ t.capacity }}')
    elif isinstance({{ src }}, _np_.ndarray) and {{ src }}.dtype == {{ t.element_type|numpy_scalar_type }}:
        {{ dst }} = {{ src }}  # Fast binding if type matches
    else:
        {{ dst }} = _np_.array({{ src }}, {{ t.element_type|numpy_scalar_type }})
{%- endmacro -%}

{%- macro data_schema(name, type) -%}
# noinspection PyUnresolvedReferences, PyPep8, PyPep8Naming, SpellCheckingInspection
class {{ name }}(_CompositeObject_):
{%- for c in type.constants %}
    {%- if c.data_type is boolean %}
    {{ new_const(c, type.constants) }} = {{ c.value.native_value }}

    {%- elif c.data_type is integer %}
    {{ new_const(c, type.constants) }} = {{ c.value.as_native_integer() }}

    {%- elif c.data_type is float %}
    {{ new_const(c, type.constants) }} = {{ c.value.native_value.numerator }} / {{ c.value.native_value.denominator }}

    {%- else -%}{%- assert False -%}
    {%- endif %}
    {{- '\n' if loop.last else '' -}}
{%- endfor %}
    def __init__(self
                 {%- if type is union -%}, *{%- endif -%}
                 {%- for f in type.fields if f is not padding -%}
                 ,
                 {{ f|id }}: {{ ''.ljust(type.fields|longest_name_length - f|id|length) -}}
                     _Optional_[{{ relaxed_type_annotation(f.data_type) }}] = None
                 {%- endfor -%}
    ):
{%- if type.deprecated %}
        _warn_('Data type {{ type }} is deprecated', DeprecationWarning)
{% endif -%}
{%- if type is not union -%}
    {% for f in type.fields if f is not padding %}
        {%- if f.data_type is boolean %}
        {{ new_field(f) }} = bool({{ f|id }}) if {{ f|id }} is not None else False

        {%- elif f.data_type is integer %}
        {{ new_field(f) }} = int({{ f|id }}) if {{ f|id }} is not None else 0

        {%- elif f.data_type is float %}
        {{ new_field(f) }} = float({{ f|id }}) if {{ f|id }} is not None else 0.0

        {%- elif f.data_type is fixed_array %}
        if {{ f|id }} is None:
            {%- if f.data_type.element_type is composite %}
            {{ new_field(f) }} = _np_.array([{{ composite_ref(f.data_type.element_type) }}() {# -#}
                                             for _ in range({{ f.data_type.capacity }})], {#  -#}
                                            {{ f.data_type.element_type|numpy_scalar_type }})
            {%- else %}
            {{ new_field(f) }} = _np_.zeros({{ f.data_type.capacity }}, {# -#}
                                            {{ f.data_type.element_type|numpy_scalar_type }})
            {%- endif %}
        else:
            {{ assign_array(f.data_type, new_field(f), (f|id)) | indent(8) }}

        {%- elif f.data_type is variable_array %}
        if {{ f|id }} is None:
            {{ new_field(f) }} = _np_.array([], {{ f.data_type.element_type|numpy_scalar_type }})
        else:
            {{ assign_array(f.data_type, new_field(f), (f|id)) | indent(8) }}

        {%- elif f.data_type is composite %}
        if {{ f|id }} is None:
            {{ new_field(f) }} = {{ composite_ref(f.data_type) }}()
        elif isinstance({{ f|id }}, {{ composite_ref(f.data_type) }}):
            {{ new_field(f) }} = {{ f|id }}
        else:
            raise ValueError(f'{{ f|id }}: expected {{ composite_ref(f.data_type) }} got {type({{ f|id }}).__name__}')

        {%- else -%}{%- assert False -%}
        {%- endif %}
    {%- else %}
        pass
    {%- endfor %}
{%- else %}  {#- IS UNION (guaranteed to contain at least 2 fields none of which are padding) #}
        """
        If no parameters are provided, the first field will be default-initialized and selected.
        If one parameter is provided, it will be used to initialize and select the field under the same name.
        If more than one parameter is provided, a ValueError will be raised.
        """
    {%- for f in type.fields %}
        self._{{ f|id }}: {{ ''.ljust(type.fields|longest_name_length - f|id|length) -}}
            _Optional_[{{ strict_type_annotation(f.data_type) }}] = None
    {%- endfor %}
        _init_cnt_: int = 0
    {% for f in type.fields %}
        if {{ f|id }} is not None:
            _init_cnt_ += 1
            self.{{ f|id }} = {{ f|id }}
    {% endfor %}
        if _init_cnt_ == 0:
    {%- set f = type.fields[0] -%}
    {%- if f.data_type is boolean %}
            self.{{ f|id }} = False

    {%- elif f.data_type is integer %}
            self.{{ f|id }} = 0

    {%- elif f.data_type is float %}
            self.{{ f|id }} = 0.0

    {%- elif f.data_type is fixed_array %}
        {%- if f.data_type.element_type is composite %}
            self.{{ f|id }} = _np_.array([{{ composite_ref(f.data_type.element_type) }}() {# -#}
                                             for _ in range({{ f.data_type.capacity }})], {#  -#}
                                            {{ f.data_type.element_type|numpy_scalar_type }})
        {%- else %}
            self.{{ f|id }} = _np_.zeros({{ f.data_type.capacity }}, {# -#}
                                            {{ f.data_type.element_type|numpy_scalar_type }})
        {%- endif %}

    {%- elif f.data_type is variable_array %}
            self.{{ f|id }} = _np_.array([], {{ f.data_type.element_type|numpy_scalar_type }})

    {%- elif f.data_type is composite %}
            self.{{ f|id }} = {{ composite_ref(f.data_type) }}()

    {%- else -%}{%- assert False -%}
    {%- endif %}  # Default initialization
        elif _init_cnt_ == 1:
            pass  # A value is already assigned, nothing to do
        else:
            raise ValueError(f'Union cannot hold values of more than one field')
{%- endif %}
{% for f in type.fields if f is not padding %}
    @property
    def {{ f|id }}(self) -> {# #}
    {%- if type is union -%}
        _Optional_[
    {%- endif -%}
        {{ strict_type_annotation(f.data_type) }}
    {%- if type is union -%}
        ]
    {%- endif -%}:
        """{{ f }}"""
        return self._{{ f|id }}

    @{{ f|id }}.setter
    def {{ f|id }}(self, x: {{ relaxed_type_annotation(f.data_type) }}) -> None:
    {%- if type is union %}
        self._reset_()
    {%- endif -%}
    {%- if f.data_type is boolean %}
        self._{{ f|id }} = bool(x)

    {%- elif f.data_type is integer %}
        self._{{ f|id }} = int(x)

    {%- elif f.data_type is float %}
        self._{{ f|id }} = float(x)

    {%- elif f.data_type is array %}
        {{ assign_array(f.data_type, ('self._' + (f|id)), 'x') | indent(4) }}
        assert isinstance(self._{{ f|id }}, _np_.ndarray)
        assert self._{{ f|id }}.dtype == {{ f.data_type.element_type|numpy_scalar_type }}
        assert len(self._{{ f|id }}) {{ '<=' if f.data_type is variable_array else '==' }} {{ f.data_type.capacity }}

    {%- elif f.data_type is composite %}
        if isinstance(x, {{ composite_ref(f.data_type) }}):
            self._{{ f|id }} = x
        else:
            raise ValueError(f'{{ f|id }}: expected {{ composite_ref(f.data_type) }} got {type(x).__name__}')

    {%- else -%}{%- assert False -%}
    {%- endif %}
{% endfor %}
{%- if type is union %}
    def _reset_(self) -> None:
    {%- for f in type.fields %}
        self._{{ f|id }} = None
    {%- endfor %}
{#  #}
{%- endif %}
    _TYPE_: _StructureType_ = _CompositeObject_._restore_constant_(
        {{ type | pickle | indent(8) }}
    )
    assert isinstance(_TYPE_, _StructureType_)
{%- endmacro -%}

{% block contents %}{% endblock %}
