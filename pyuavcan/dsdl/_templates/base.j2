{#-
 # Copyright (c) 2019 UAVCAN Development Team
 # This software is distributed under the terms of the MIT License.
 # Author: Pavel Kirienko <pavel.kirienko@zubax.com>
-#}
#
# AUTOGENERATED, DO NOT EDIT.
#
# Source file:
# {{ T.source_file_path }}
#
# Generated at:  {{ now_utc }} UTC
# Is deprecated: {{ T.deprecated and 'yes' or 'no' }}
# Fixed port ID: {{ T.fixed_port_id }}
# Full name:     {{ T.full_name }}
# Version:       {{ T.version.major }}.{{ T.version.minor }}
#

import numpy as _np_
import typing as _ty_
import pydsdl as _pydsdl_
import pyuavcan.dsdl as _dsdl_
{%- if T.deprecated %}
import warnings as _warnings_
{%- endif -%}
{%- for n in T|imports %}
import {{ n }}
{%- endfor %}

{%- from 'serialization.j2' import serialize, deserialize -%}


{#-
 # BASIC CONSTRUCTS
-#}
{%- macro composite_ref(t) -%}
    {{ t.full_name }}_{{ t.version.major }}_{{ t.version.minor }}
{%- endmacro -%}

{%- macro new_const(c, siblings) -%}
    {{ c|id }}: {{ ''.ljust(siblings|longest_id_length - c|id|length) }}{{ strict_type_annotation(c.data_type) }}
{%- endmacro -%}


{#-
 # FIELD TYPE ANNOTATIONS.
-#}
{%- macro strict_type_annotation(t) -%}
    {%-   if t is boolean   -%} bool
    {%- elif t is integer   -%} int
    {%- elif t is float     -%} float
    {%- elif t is array     -%} _np_.ndarray
    {%- elif t is composite -%} {{ composite_ref(t) }}
    {%- else -%}{% assert False %}
    {%- endif -%}
{%- endmacro -%}

{%- macro relaxed_type_annotation(t) -%}
    {%-   if t is boolean   -%} bool
    {%- elif t is integer   -%} _ty_.Union[int, {{ t|numpy_scalar_type }}]
    {%- elif t is float     -%} _ty_.Union[int, float, {{ t|numpy_scalar_type }}]
    {%- elif t is composite -%} {{ composite_ref(t) }}
    {%- elif t is array -%}
        {%- if (t.element_type is uint) and t.element_type.bit_length <= 8 -%}
            _ty_.Union[_np_.ndarray, _ty_.List[int], bytes, bytearray{%- if t.string_like -%}, str{%- endif -%}]
        {%- else -%}
            _ty_.Union[_np_.ndarray, _ty_.List[{{ strict_type_annotation(t.element_type) }}]]
        {%- endif -%}
    {%- else -%}{% assert False %}
    {%- endif -%}
{%- endmacro -%}


{#-
 # ARRAY ASSIGNMENT BLOCK.
 # Validates the type and dimensionality of the input array, and converts it into the proper type as necessary.
 # Emits post-assignment invariant checks to ensure correct behavior of the generated code.
-#}
{%- macro assign_array(f, src) -%}
    {%- set t = f.data_type -%}
    {%- if t is fixed_array -%}         {%- set cmp = '!=' -%}
    {%- elif t is variable_array -%}    {%- set cmp = '>' -%}
    {%- else -%}                        {%- assert False -%}
    {%- endif -%}

    {%- if t.string_like -%}
    {#- Python uses UTF-8 by default, just like DSDL. -#}
    {{ src }} = {{ src }}.encode() if isinstance({{ src }}, str) else {{ src }}
    {% endif -%}
    {%- if t.element_type is uint and t.element_type.bit_length <= 8 -%}
    {#- We must convert bytes into bytearray because NumPy treats bytes as string, trying to parse it and failing. -#}
    {{ src }} = bytearray({{ src }}) if isinstance({{ src }}, bytes) else {{ src }}
    {% endif -%}

    if len({{ src }}) {{ cmp }} {{ t.capacity }}:
        raise ValueError(f'{{ f.name }}: invalid array length: {len({{ src }})} {{ cmp }} {{ t.capacity }}')
    elif isinstance({{ src }}, _np_.ndarray) and {{ src }}.dtype == {{ t.element_type|numpy_scalar_type }} {# -#}
     and {{ src }}.ndim == 1:
        self._{{ f|id }} = {{ src }}  # Fast binding if type/dimension match
    else:
        self._{{ f|id }} = _np_.array({{ src }}, {{ t.element_type|numpy_scalar_type }})
    assert isinstance(self._{{ f|id }}, _np_.ndarray)
    assert self._{{ f|id }}.dtype == {{ t.element_type|numpy_scalar_type }}
    assert self._{{ f|id }}.ndim == 1
    assert len(self._{{ f|id }}) {{ '<=' if t is variable_array else '==' }} {{ t.capacity }}
{%- endmacro -%}

{#-
 # MAIN CODE GENERATION MACRO.
 # Accepts the name of the generated type and its DSDL type descriptor object of type pydsdl.CompositeType.
-#}
{%- macro data_schema(name, type) -%}
# noinspection PyUnresolvedReferences, PyPep8, PyPep8Naming, SpellCheckingInspection
class {{ name }}(_dsdl_.CompositeObject):
{#-
 # CONSTANTS
-#}
{%- for c in type.constants %}
    {%- if c.data_type is boolean %}
    {{ new_const(c, type.constants) }} = {{ c.value.native_value }}

    {%- elif c.data_type is integer %}
    {{ new_const(c, type.constants) }} = {{ c.value.as_native_integer() }}

    {%- elif c.data_type is float %}
    {{ new_const(c, type.constants) }} = {{ c.value.native_value.numerator }} / {{ c.value.native_value.denominator }}

    {%- else -%}{%- assert False -%}
    {%- endif %}
    {{- '\n' if loop.last else '' -}}
{%- endfor %}
    def __init__(self
                 {%- if type is union -%}, *{%- endif -%}
                 {%- for f in type.fields if f is not padding -%}
                 ,
                 {{ f|id }}: {{ ''.ljust(type.fields|longest_id_length - f|id|length) -}}
                     _ty_.Optional[{{ relaxed_type_annotation(f.data_type) }}] = None
                 {%- endfor -%}
    ):
        """
        {{ type.full_name }}.{{ type.version.major }}.{{ type.version.minor }}
        {%- if type is union %}
        If no parameters are provided, the first field will be default-initialized and selected.
        If one parameter is provided, it will be used to initialize and select the field under the same name.
        If more than one parameter is provided, a ValueError will be raised.
        {%- endif %}
{%- for f in type.fields if f is not padding %}
        :param {{ f|id }}: {{ ''.ljust(type.fields|longest_id_length - f|id|length) }}{{ f }}
{%- endfor %}
        """
{%- if type.deprecated %}
        _warnings_.warn('Data type {{ type }} is deprecated', DeprecationWarning)
{% endif -%}

{#-
 # FIELD INITIALIZATION
-#}
{%- if type is not union -%}
    {%- for f in type.fields if f is not padding %}
        self._{{ f|id }}: {{ ''.ljust(type.fields|longest_id_length - f|id|length) -}}
                          {{- strict_type_annotation(f.data_type) }}
        {{- '\n' if loop.last else '' -}}
    {%- endfor %}
    {%- for f in type.fields if f is not padding %}
        {%- if f.data_type is boolean %}
        self._{{ f|id }} = bool({{ f|id }}) if {{ f|id }} is not None else False

        {%- elif f.data_type is integer %}
        self._{{ f|id }} = int({{ f|id }}) if {{ f|id }} is not None else 0

        {%- elif f.data_type is float %}
        self._{{ f|id }} = float({{ f|id }}) if {{ f|id }} is not None else 0.0

        {%- elif f.data_type is fixed_array %}
        if {{ f|id }} is None:
            {%- if f.data_type.element_type is composite %}
            self._{{ f|id }} = _np_.array([{{ composite_ref(f.data_type.element_type) }}() {# -#}
                                           for _ in range({{ f.data_type.capacity }})], {#  -#}
                                          {{ f.data_type.element_type|numpy_scalar_type }})
            {%- else %}
            self._{{ f|id }} = _np_.zeros({{ f.data_type.capacity }}, {# -#}
                                          {{ f.data_type.element_type|numpy_scalar_type }})
            {%- endif %}
        else:
            {{ assign_array(f, f|id) | indent(8) }}

        {%- elif f.data_type is variable_array %}
        if {{ f|id }} is None:
            self._{{ f|id }} = _np_.array([], {{ f.data_type.element_type|numpy_scalar_type }})
        else:
            {{ assign_array(f, f|id) | indent(8) }}

        {%- elif f.data_type is composite %}
        if {{ f|id }} is None:
            self._{{ f|id }} = {{ composite_ref(f.data_type) }}()
        elif isinstance({{ f|id }}, {{ composite_ref(f.data_type) }}):
            self._{{ f|id }} = {{ f|id }}
        else:
            raise ValueError(f'{{ f|id }}: expected {{ composite_ref(f.data_type) }} got {type({{ f|id }}).__name__}')

        {%- else -%}{%- assert False -%}
        {%- endif %}
    {% else %}
        pass
{# #}
    {%- endfor %}
{%- else %}  {#- IS UNION (guaranteed to contain at least 2 fields none of which are padding) #}
    {%- for f in type.fields %}
        self._{{ f|id }}: {{ ''.ljust(type.fields|longest_id_length - f|id|length) -}}
            _ty_.Optional[{{ strict_type_annotation(f.data_type) }}] = None
    {%- endfor %}
        _init_cnt_: int = 0
    {% for f in type.fields %}
        if {{ f|id }} is not None:
            _init_cnt_ += 1
            self.{{ f|id }} = {{ f|id }}
    {% endfor %}
        if _init_cnt_ == 0:
    {%- set f = type.fields[0] -%}
    {%- if f.data_type is boolean %}
            self.{{ f|id }} = False

    {%- elif f.data_type is integer %}
            self.{{ f|id }} = 0

    {%- elif f.data_type is float %}
            self.{{ f|id }} = 0.0

    {%- elif f.data_type is fixed_array %}
        {%- if f.data_type.element_type is composite %}
            self.{{ f|id }} = _np_.array([{{ composite_ref(f.data_type.element_type) }}() {# -#}
                                             for _ in range({{ f.data_type.capacity }})], {#  -#}
                                            {{ f.data_type.element_type|numpy_scalar_type }})
        {%- else %}
            self.{{ f|id }} = _np_.zeros({{ f.data_type.capacity }}, {# -#}
                                            {{ f.data_type.element_type|numpy_scalar_type }})
        {%- endif %}

    {%- elif f.data_type is variable_array %}
            self.{{ f|id }} = _np_.array([], {{ f.data_type.element_type|numpy_scalar_type }})

    {%- elif f.data_type is composite %}
            self.{{ f|id }} = {{ composite_ref(f.data_type) }}()

    {%- else -%}{%- assert False -%}
    {%- endif %}  # Default initialization
        elif _init_cnt_ == 1:
            pass  # A value is already assigned, nothing to do
        else:
            raise ValueError(f'Union cannot hold values of more than one field')
{# #}
{%- endif %}

{#-
 # FIELD ACCESSORS AND MUTATORS
-#}
{%- for f in type.fields if f is not padding %}
    @property
    def {{ f|id }}(self) -> {# #}
    {%- if type is union -%}
        _ty_.Optional[
    {%- endif -%}
        {{ strict_type_annotation(f.data_type) }}
    {%- if type is union -%}
        ]
    {%- endif -%}:
        """{{ f }}"""
        return self._{{ f|id }}

    @{{ f|id }}.setter
    def {{ f|id }}(self, x: {{ relaxed_type_annotation(f.data_type) }}) -> None:
    {%- if f.data_type is boolean %}
        self._{{ f|id }} = bool(x)

    {%- elif f.data_type is integer %}
        self._{{ f|id }} = int(x)

    {%- elif f.data_type is float %}
        self._{{ f|id }} = float(x)

    {%- elif f.data_type is array %}
        {{ assign_array(f, 'x') | indent(4) }}

    {%- elif f.data_type is composite %}
        if isinstance(x, {{ composite_ref(f.data_type) }}):
            self._{{ f|id }} = x
        else:
            raise ValueError(f'{{ f|id }}: expected {{ composite_ref(f.data_type) }} got {type(x).__name__}')

    {%- else -%}{%- assert False -%}
    {%- endif %}
    {%- if type is union %}
        {%- for z in type.fields if z.name != f.name %}
        self._{{ z|id }} = None
        {%- endfor %}
    {%- endif %}
{% endfor -%}
{#
 # SERIALIZATION METHODS
 #}
    def _serialize_(self) -> _dsdl_.Serializer:
        {{ serialize(type, 'self')|indent }}

    @staticmethod
    def _deserialize_(source: _dsdl_.Deserializer) -> _dsdl_.CompositeObject:
        {{ deserialize(type, 'self')|indent }}
{#
 # PYDSDL TYPE DESCRIPTOR
 #}
    {% set meta_type = 'UnionType' if type is union else 'StructureType' -%}
    _TYPE_: _pydsdl_.{{ meta_type }} = _dsdl_.CompositeObject._restore_constant_(
        {{ type | pickle | indent(8) }}
    )
    assert isinstance(_TYPE_, _pydsdl_.{{ meta_type }})
{%- endmacro -%}

{#-
 # The position of this comment defines the number of blank lines between imports and class definition.
 # Do not put any definitions below.
 #}


{% block contents %}{% endblock %}
